// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: transport.proto

#ifndef PROTOBUF_INCLUDED_transport_2eproto
#define PROTOBUF_INCLUDED_transport_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_transport_2eproto 

namespace protobuf_transport_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[16];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_transport_2eproto
namespace flower {
namespace transport {
class ClientMessage;
class ClientMessageDefaultTypeInternal;
extern ClientMessageDefaultTypeInternal _ClientMessage_default_instance_;
class ClientMessage_Disconnect;
class ClientMessage_DisconnectDefaultTypeInternal;
extern ClientMessage_DisconnectDefaultTypeInternal _ClientMessage_Disconnect_default_instance_;
class ClientMessage_EvaluateRes;
class ClientMessage_EvaluateResDefaultTypeInternal;
extern ClientMessage_EvaluateResDefaultTypeInternal _ClientMessage_EvaluateRes_default_instance_;
class ClientMessage_EvaluateRes_MetricsEntry_DoNotUse;
class ClientMessage_EvaluateRes_MetricsEntry_DoNotUseDefaultTypeInternal;
extern ClientMessage_EvaluateRes_MetricsEntry_DoNotUseDefaultTypeInternal _ClientMessage_EvaluateRes_MetricsEntry_DoNotUse_default_instance_;
class ClientMessage_FitRes;
class ClientMessage_FitResDefaultTypeInternal;
extern ClientMessage_FitResDefaultTypeInternal _ClientMessage_FitRes_default_instance_;
class ClientMessage_FitRes_MetricsEntry_DoNotUse;
class ClientMessage_FitRes_MetricsEntry_DoNotUseDefaultTypeInternal;
extern ClientMessage_FitRes_MetricsEntry_DoNotUseDefaultTypeInternal _ClientMessage_FitRes_MetricsEntry_DoNotUse_default_instance_;
class ClientMessage_ParametersRes;
class ClientMessage_ParametersResDefaultTypeInternal;
extern ClientMessage_ParametersResDefaultTypeInternal _ClientMessage_ParametersRes_default_instance_;
class Parameters;
class ParametersDefaultTypeInternal;
extern ParametersDefaultTypeInternal _Parameters_default_instance_;
class Scalar;
class ScalarDefaultTypeInternal;
extern ScalarDefaultTypeInternal _Scalar_default_instance_;
class ServerMessage;
class ServerMessageDefaultTypeInternal;
extern ServerMessageDefaultTypeInternal _ServerMessage_default_instance_;
class ServerMessage_EvaluateIns;
class ServerMessage_EvaluateInsDefaultTypeInternal;
extern ServerMessage_EvaluateInsDefaultTypeInternal _ServerMessage_EvaluateIns_default_instance_;
class ServerMessage_EvaluateIns_ConfigEntry_DoNotUse;
class ServerMessage_EvaluateIns_ConfigEntry_DoNotUseDefaultTypeInternal;
extern ServerMessage_EvaluateIns_ConfigEntry_DoNotUseDefaultTypeInternal _ServerMessage_EvaluateIns_ConfigEntry_DoNotUse_default_instance_;
class ServerMessage_FitIns;
class ServerMessage_FitInsDefaultTypeInternal;
extern ServerMessage_FitInsDefaultTypeInternal _ServerMessage_FitIns_default_instance_;
class ServerMessage_FitIns_ConfigEntry_DoNotUse;
class ServerMessage_FitIns_ConfigEntry_DoNotUseDefaultTypeInternal;
extern ServerMessage_FitIns_ConfigEntry_DoNotUseDefaultTypeInternal _ServerMessage_FitIns_ConfigEntry_DoNotUse_default_instance_;
class ServerMessage_GetParameters;
class ServerMessage_GetParametersDefaultTypeInternal;
extern ServerMessage_GetParametersDefaultTypeInternal _ServerMessage_GetParameters_default_instance_;
class ServerMessage_Reconnect;
class ServerMessage_ReconnectDefaultTypeInternal;
extern ServerMessage_ReconnectDefaultTypeInternal _ServerMessage_Reconnect_default_instance_;
}  // namespace transport
}  // namespace flower
namespace google {
namespace protobuf {
template<> ::flower::transport::ClientMessage* Arena::CreateMaybeMessage<::flower::transport::ClientMessage>(Arena*);
template<> ::flower::transport::ClientMessage_Disconnect* Arena::CreateMaybeMessage<::flower::transport::ClientMessage_Disconnect>(Arena*);
template<> ::flower::transport::ClientMessage_EvaluateRes* Arena::CreateMaybeMessage<::flower::transport::ClientMessage_EvaluateRes>(Arena*);
template<> ::flower::transport::ClientMessage_EvaluateRes_MetricsEntry_DoNotUse* Arena::CreateMaybeMessage<::flower::transport::ClientMessage_EvaluateRes_MetricsEntry_DoNotUse>(Arena*);
template<> ::flower::transport::ClientMessage_FitRes* Arena::CreateMaybeMessage<::flower::transport::ClientMessage_FitRes>(Arena*);
template<> ::flower::transport::ClientMessage_FitRes_MetricsEntry_DoNotUse* Arena::CreateMaybeMessage<::flower::transport::ClientMessage_FitRes_MetricsEntry_DoNotUse>(Arena*);
template<> ::flower::transport::ClientMessage_ParametersRes* Arena::CreateMaybeMessage<::flower::transport::ClientMessage_ParametersRes>(Arena*);
template<> ::flower::transport::Parameters* Arena::CreateMaybeMessage<::flower::transport::Parameters>(Arena*);
template<> ::flower::transport::Scalar* Arena::CreateMaybeMessage<::flower::transport::Scalar>(Arena*);
template<> ::flower::transport::ServerMessage* Arena::CreateMaybeMessage<::flower::transport::ServerMessage>(Arena*);
template<> ::flower::transport::ServerMessage_EvaluateIns* Arena::CreateMaybeMessage<::flower::transport::ServerMessage_EvaluateIns>(Arena*);
template<> ::flower::transport::ServerMessage_EvaluateIns_ConfigEntry_DoNotUse* Arena::CreateMaybeMessage<::flower::transport::ServerMessage_EvaluateIns_ConfigEntry_DoNotUse>(Arena*);
template<> ::flower::transport::ServerMessage_FitIns* Arena::CreateMaybeMessage<::flower::transport::ServerMessage_FitIns>(Arena*);
template<> ::flower::transport::ServerMessage_FitIns_ConfigEntry_DoNotUse* Arena::CreateMaybeMessage<::flower::transport::ServerMessage_FitIns_ConfigEntry_DoNotUse>(Arena*);
template<> ::flower::transport::ServerMessage_GetParameters* Arena::CreateMaybeMessage<::flower::transport::ServerMessage_GetParameters>(Arena*);
template<> ::flower::transport::ServerMessage_Reconnect* Arena::CreateMaybeMessage<::flower::transport::ServerMessage_Reconnect>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace flower {
namespace transport {

enum Reason {
  UNKNOWN = 0,
  RECONNECT = 1,
  POWER_DISCONNECTED = 2,
  WIFI_UNAVAILABLE = 3,
  ACK = 4,
  Reason_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Reason_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Reason_IsValid(int value);
const Reason Reason_MIN = UNKNOWN;
const Reason Reason_MAX = ACK;
const int Reason_ARRAYSIZE = Reason_MAX + 1;

const ::google::protobuf::EnumDescriptor* Reason_descriptor();
inline const ::std::string& Reason_Name(Reason value) {
  return ::google::protobuf::internal::NameOfEnum(
    Reason_descriptor(), value);
}
inline bool Reason_Parse(
    const ::std::string& name, Reason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Reason>(
    Reason_descriptor(), name, value);
}
// ===================================================================

class Parameters : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flower.transport.Parameters) */ {
 public:
  Parameters();
  virtual ~Parameters();

  Parameters(const Parameters& from);

  inline Parameters& operator=(const Parameters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Parameters(Parameters&& from) noexcept
    : Parameters() {
    *this = ::std::move(from);
  }

  inline Parameters& operator=(Parameters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Parameters* internal_default_instance() {
    return reinterpret_cast<const Parameters*>(
               &_Parameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Parameters* other);
  friend void swap(Parameters& a, Parameters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Parameters* New() const final {
    return CreateMaybeMessage<Parameters>(NULL);
  }

  Parameters* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Parameters>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Parameters& from);
  void MergeFrom(const Parameters& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Parameters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes tensors = 1;
  int tensors_size() const;
  void clear_tensors();
  static const int kTensorsFieldNumber = 1;
  const ::std::string& tensors(int index) const;
  ::std::string* mutable_tensors(int index);
  void set_tensors(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tensors(int index, ::std::string&& value);
  #endif
  void set_tensors(int index, const char* value);
  void set_tensors(int index, const void* value, size_t size);
  ::std::string* add_tensors();
  void add_tensors(const ::std::string& value);
  #if LANG_CXX11
  void add_tensors(::std::string&& value);
  #endif
  void add_tensors(const char* value);
  void add_tensors(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tensors() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tensors();

  // string tensor_type = 2;
  void clear_tensor_type();
  static const int kTensorTypeFieldNumber = 2;
  const ::std::string& tensor_type() const;
  void set_tensor_type(const ::std::string& value);
  #if LANG_CXX11
  void set_tensor_type(::std::string&& value);
  #endif
  void set_tensor_type(const char* value);
  void set_tensor_type(const char* value, size_t size);
  ::std::string* mutable_tensor_type();
  ::std::string* release_tensor_type();
  void set_allocated_tensor_type(::std::string* tensor_type);

  // @@protoc_insertion_point(class_scope:flower.transport.Parameters)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tensors_;
  ::google::protobuf::internal::ArenaStringPtr tensor_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_transport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerMessage_Reconnect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flower.transport.ServerMessage.Reconnect) */ {
 public:
  ServerMessage_Reconnect();
  virtual ~ServerMessage_Reconnect();

  ServerMessage_Reconnect(const ServerMessage_Reconnect& from);

  inline ServerMessage_Reconnect& operator=(const ServerMessage_Reconnect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerMessage_Reconnect(ServerMessage_Reconnect&& from) noexcept
    : ServerMessage_Reconnect() {
    *this = ::std::move(from);
  }

  inline ServerMessage_Reconnect& operator=(ServerMessage_Reconnect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMessage_Reconnect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerMessage_Reconnect* internal_default_instance() {
    return reinterpret_cast<const ServerMessage_Reconnect*>(
               &_ServerMessage_Reconnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ServerMessage_Reconnect* other);
  friend void swap(ServerMessage_Reconnect& a, ServerMessage_Reconnect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerMessage_Reconnect* New() const final {
    return CreateMaybeMessage<ServerMessage_Reconnect>(NULL);
  }

  ServerMessage_Reconnect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerMessage_Reconnect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerMessage_Reconnect& from);
  void MergeFrom(const ServerMessage_Reconnect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMessage_Reconnect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 seconds = 1;
  void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  ::google::protobuf::int64 seconds() const;
  void set_seconds(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:flower.transport.ServerMessage.Reconnect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 seconds_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_transport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerMessage_GetParameters : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flower.transport.ServerMessage.GetParameters) */ {
 public:
  ServerMessage_GetParameters();
  virtual ~ServerMessage_GetParameters();

  ServerMessage_GetParameters(const ServerMessage_GetParameters& from);

  inline ServerMessage_GetParameters& operator=(const ServerMessage_GetParameters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerMessage_GetParameters(ServerMessage_GetParameters&& from) noexcept
    : ServerMessage_GetParameters() {
    *this = ::std::move(from);
  }

  inline ServerMessage_GetParameters& operator=(ServerMessage_GetParameters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMessage_GetParameters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerMessage_GetParameters* internal_default_instance() {
    return reinterpret_cast<const ServerMessage_GetParameters*>(
               &_ServerMessage_GetParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ServerMessage_GetParameters* other);
  friend void swap(ServerMessage_GetParameters& a, ServerMessage_GetParameters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerMessage_GetParameters* New() const final {
    return CreateMaybeMessage<ServerMessage_GetParameters>(NULL);
  }

  ServerMessage_GetParameters* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerMessage_GetParameters>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerMessage_GetParameters& from);
  void MergeFrom(const ServerMessage_GetParameters& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMessage_GetParameters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flower.transport.ServerMessage.GetParameters)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_transport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerMessage_FitIns_ConfigEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ServerMessage_FitIns_ConfigEntry_DoNotUse, 
    ::std::string, ::flower::transport::Scalar,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ServerMessage_FitIns_ConfigEntry_DoNotUse, 
    ::std::string, ::flower::transport::Scalar,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  ServerMessage_FitIns_ConfigEntry_DoNotUse();
  ServerMessage_FitIns_ConfigEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ServerMessage_FitIns_ConfigEntry_DoNotUse& other);
  static const ServerMessage_FitIns_ConfigEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ServerMessage_FitIns_ConfigEntry_DoNotUse*>(&_ServerMessage_FitIns_ConfigEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ServerMessage_FitIns : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flower.transport.ServerMessage.FitIns) */ {
 public:
  ServerMessage_FitIns();
  virtual ~ServerMessage_FitIns();

  ServerMessage_FitIns(const ServerMessage_FitIns& from);

  inline ServerMessage_FitIns& operator=(const ServerMessage_FitIns& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerMessage_FitIns(ServerMessage_FitIns&& from) noexcept
    : ServerMessage_FitIns() {
    *this = ::std::move(from);
  }

  inline ServerMessage_FitIns& operator=(ServerMessage_FitIns&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMessage_FitIns& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerMessage_FitIns* internal_default_instance() {
    return reinterpret_cast<const ServerMessage_FitIns*>(
               &_ServerMessage_FitIns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ServerMessage_FitIns* other);
  friend void swap(ServerMessage_FitIns& a, ServerMessage_FitIns& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerMessage_FitIns* New() const final {
    return CreateMaybeMessage<ServerMessage_FitIns>(NULL);
  }

  ServerMessage_FitIns* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerMessage_FitIns>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerMessage_FitIns& from);
  void MergeFrom(const ServerMessage_FitIns& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMessage_FitIns* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .flower.transport.Scalar> config = 2;
  int config_size() const;
  void clear_config();
  static const int kConfigFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::flower::transport::Scalar >&
      config() const;
  ::google::protobuf::Map< ::std::string, ::flower::transport::Scalar >*
      mutable_config();

  // .flower.transport.Parameters parameters = 1;
  bool has_parameters() const;
  void clear_parameters();
  static const int kParametersFieldNumber = 1;
  private:
  const ::flower::transport::Parameters& _internal_parameters() const;
  public:
  const ::flower::transport::Parameters& parameters() const;
  ::flower::transport::Parameters* release_parameters();
  ::flower::transport::Parameters* mutable_parameters();
  void set_allocated_parameters(::flower::transport::Parameters* parameters);

  // @@protoc_insertion_point(class_scope:flower.transport.ServerMessage.FitIns)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      ServerMessage_FitIns_ConfigEntry_DoNotUse,
      ::std::string, ::flower::transport::Scalar,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > config_;
  ::flower::transport::Parameters* parameters_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_transport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerMessage_EvaluateIns_ConfigEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ServerMessage_EvaluateIns_ConfigEntry_DoNotUse, 
    ::std::string, ::flower::transport::Scalar,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ServerMessage_EvaluateIns_ConfigEntry_DoNotUse, 
    ::std::string, ::flower::transport::Scalar,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  ServerMessage_EvaluateIns_ConfigEntry_DoNotUse();
  ServerMessage_EvaluateIns_ConfigEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ServerMessage_EvaluateIns_ConfigEntry_DoNotUse& other);
  static const ServerMessage_EvaluateIns_ConfigEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ServerMessage_EvaluateIns_ConfigEntry_DoNotUse*>(&_ServerMessage_EvaluateIns_ConfigEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ServerMessage_EvaluateIns : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flower.transport.ServerMessage.EvaluateIns) */ {
 public:
  ServerMessage_EvaluateIns();
  virtual ~ServerMessage_EvaluateIns();

  ServerMessage_EvaluateIns(const ServerMessage_EvaluateIns& from);

  inline ServerMessage_EvaluateIns& operator=(const ServerMessage_EvaluateIns& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerMessage_EvaluateIns(ServerMessage_EvaluateIns&& from) noexcept
    : ServerMessage_EvaluateIns() {
    *this = ::std::move(from);
  }

  inline ServerMessage_EvaluateIns& operator=(ServerMessage_EvaluateIns&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMessage_EvaluateIns& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerMessage_EvaluateIns* internal_default_instance() {
    return reinterpret_cast<const ServerMessage_EvaluateIns*>(
               &_ServerMessage_EvaluateIns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ServerMessage_EvaluateIns* other);
  friend void swap(ServerMessage_EvaluateIns& a, ServerMessage_EvaluateIns& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerMessage_EvaluateIns* New() const final {
    return CreateMaybeMessage<ServerMessage_EvaluateIns>(NULL);
  }

  ServerMessage_EvaluateIns* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerMessage_EvaluateIns>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerMessage_EvaluateIns& from);
  void MergeFrom(const ServerMessage_EvaluateIns& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMessage_EvaluateIns* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .flower.transport.Scalar> config = 2;
  int config_size() const;
  void clear_config();
  static const int kConfigFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::flower::transport::Scalar >&
      config() const;
  ::google::protobuf::Map< ::std::string, ::flower::transport::Scalar >*
      mutable_config();

  // .flower.transport.Parameters parameters = 1;
  bool has_parameters() const;
  void clear_parameters();
  static const int kParametersFieldNumber = 1;
  private:
  const ::flower::transport::Parameters& _internal_parameters() const;
  public:
  const ::flower::transport::Parameters& parameters() const;
  ::flower::transport::Parameters* release_parameters();
  ::flower::transport::Parameters* mutable_parameters();
  void set_allocated_parameters(::flower::transport::Parameters* parameters);

  // @@protoc_insertion_point(class_scope:flower.transport.ServerMessage.EvaluateIns)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      ServerMessage_EvaluateIns_ConfigEntry_DoNotUse,
      ::std::string, ::flower::transport::Scalar,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > config_;
  ::flower::transport::Parameters* parameters_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_transport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flower.transport.ServerMessage) */ {
 public:
  ServerMessage();
  virtual ~ServerMessage();

  ServerMessage(const ServerMessage& from);

  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerMessage(ServerMessage&& from) noexcept
    : ServerMessage() {
    *this = ::std::move(from);
  }

  inline ServerMessage& operator=(ServerMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMessage& default_instance();

  enum MsgCase {
    kReconnect = 1,
    kGetParameters = 2,
    kFitIns = 3,
    kEvaluateIns = 4,
    MSG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerMessage* internal_default_instance() {
    return reinterpret_cast<const ServerMessage*>(
               &_ServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ServerMessage* other);
  friend void swap(ServerMessage& a, ServerMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerMessage* New() const final {
    return CreateMaybeMessage<ServerMessage>(NULL);
  }

  ServerMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerMessage& from);
  void MergeFrom(const ServerMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ServerMessage_Reconnect Reconnect;
  typedef ServerMessage_GetParameters GetParameters;
  typedef ServerMessage_FitIns FitIns;
  typedef ServerMessage_EvaluateIns EvaluateIns;

  // accessors -------------------------------------------------------

  // .flower.transport.ServerMessage.Reconnect reconnect = 1;
  bool has_reconnect() const;
  void clear_reconnect();
  static const int kReconnectFieldNumber = 1;
  private:
  const ::flower::transport::ServerMessage_Reconnect& _internal_reconnect() const;
  public:
  const ::flower::transport::ServerMessage_Reconnect& reconnect() const;
  ::flower::transport::ServerMessage_Reconnect* release_reconnect();
  ::flower::transport::ServerMessage_Reconnect* mutable_reconnect();
  void set_allocated_reconnect(::flower::transport::ServerMessage_Reconnect* reconnect);

  // .flower.transport.ServerMessage.GetParameters get_parameters = 2;
  bool has_get_parameters() const;
  void clear_get_parameters();
  static const int kGetParametersFieldNumber = 2;
  private:
  const ::flower::transport::ServerMessage_GetParameters& _internal_get_parameters() const;
  public:
  const ::flower::transport::ServerMessage_GetParameters& get_parameters() const;
  ::flower::transport::ServerMessage_GetParameters* release_get_parameters();
  ::flower::transport::ServerMessage_GetParameters* mutable_get_parameters();
  void set_allocated_get_parameters(::flower::transport::ServerMessage_GetParameters* get_parameters);

  // .flower.transport.ServerMessage.FitIns fit_ins = 3;
  bool has_fit_ins() const;
  void clear_fit_ins();
  static const int kFitInsFieldNumber = 3;
  private:
  const ::flower::transport::ServerMessage_FitIns& _internal_fit_ins() const;
  public:
  const ::flower::transport::ServerMessage_FitIns& fit_ins() const;
  ::flower::transport::ServerMessage_FitIns* release_fit_ins();
  ::flower::transport::ServerMessage_FitIns* mutable_fit_ins();
  void set_allocated_fit_ins(::flower::transport::ServerMessage_FitIns* fit_ins);

  // .flower.transport.ServerMessage.EvaluateIns evaluate_ins = 4;
  bool has_evaluate_ins() const;
  void clear_evaluate_ins();
  static const int kEvaluateInsFieldNumber = 4;
  private:
  const ::flower::transport::ServerMessage_EvaluateIns& _internal_evaluate_ins() const;
  public:
  const ::flower::transport::ServerMessage_EvaluateIns& evaluate_ins() const;
  ::flower::transport::ServerMessage_EvaluateIns* release_evaluate_ins();
  ::flower::transport::ServerMessage_EvaluateIns* mutable_evaluate_ins();
  void set_allocated_evaluate_ins(::flower::transport::ServerMessage_EvaluateIns* evaluate_ins);

  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:flower.transport.ServerMessage)
 private:
  void set_has_reconnect();
  void set_has_get_parameters();
  void set_has_fit_ins();
  void set_has_evaluate_ins();

  inline bool has_msg() const;
  inline void clear_has_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union MsgUnion {
    MsgUnion() {}
    ::flower::transport::ServerMessage_Reconnect* reconnect_;
    ::flower::transport::ServerMessage_GetParameters* get_parameters_;
    ::flower::transport::ServerMessage_FitIns* fit_ins_;
    ::flower::transport::ServerMessage_EvaluateIns* evaluate_ins_;
  } msg_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_transport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientMessage_Disconnect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flower.transport.ClientMessage.Disconnect) */ {
 public:
  ClientMessage_Disconnect();
  virtual ~ClientMessage_Disconnect();

  ClientMessage_Disconnect(const ClientMessage_Disconnect& from);

  inline ClientMessage_Disconnect& operator=(const ClientMessage_Disconnect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientMessage_Disconnect(ClientMessage_Disconnect&& from) noexcept
    : ClientMessage_Disconnect() {
    *this = ::std::move(from);
  }

  inline ClientMessage_Disconnect& operator=(ClientMessage_Disconnect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_Disconnect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientMessage_Disconnect* internal_default_instance() {
    return reinterpret_cast<const ClientMessage_Disconnect*>(
               &_ClientMessage_Disconnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ClientMessage_Disconnect* other);
  friend void swap(ClientMessage_Disconnect& a, ClientMessage_Disconnect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientMessage_Disconnect* New() const final {
    return CreateMaybeMessage<ClientMessage_Disconnect>(NULL);
  }

  ClientMessage_Disconnect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientMessage_Disconnect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientMessage_Disconnect& from);
  void MergeFrom(const ClientMessage_Disconnect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientMessage_Disconnect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flower.transport.Reason reason = 1;
  void clear_reason();
  static const int kReasonFieldNumber = 1;
  ::flower::transport::Reason reason() const;
  void set_reason(::flower::transport::Reason value);

  // @@protoc_insertion_point(class_scope:flower.transport.ClientMessage.Disconnect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int reason_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_transport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientMessage_ParametersRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flower.transport.ClientMessage.ParametersRes) */ {
 public:
  ClientMessage_ParametersRes();
  virtual ~ClientMessage_ParametersRes();

  ClientMessage_ParametersRes(const ClientMessage_ParametersRes& from);

  inline ClientMessage_ParametersRes& operator=(const ClientMessage_ParametersRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientMessage_ParametersRes(ClientMessage_ParametersRes&& from) noexcept
    : ClientMessage_ParametersRes() {
    *this = ::std::move(from);
  }

  inline ClientMessage_ParametersRes& operator=(ClientMessage_ParametersRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_ParametersRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientMessage_ParametersRes* internal_default_instance() {
    return reinterpret_cast<const ClientMessage_ParametersRes*>(
               &_ClientMessage_ParametersRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ClientMessage_ParametersRes* other);
  friend void swap(ClientMessage_ParametersRes& a, ClientMessage_ParametersRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientMessage_ParametersRes* New() const final {
    return CreateMaybeMessage<ClientMessage_ParametersRes>(NULL);
  }

  ClientMessage_ParametersRes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientMessage_ParametersRes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientMessage_ParametersRes& from);
  void MergeFrom(const ClientMessage_ParametersRes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientMessage_ParametersRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flower.transport.Parameters parameters = 1;
  bool has_parameters() const;
  void clear_parameters();
  static const int kParametersFieldNumber = 1;
  private:
  const ::flower::transport::Parameters& _internal_parameters() const;
  public:
  const ::flower::transport::Parameters& parameters() const;
  ::flower::transport::Parameters* release_parameters();
  ::flower::transport::Parameters* mutable_parameters();
  void set_allocated_parameters(::flower::transport::Parameters* parameters);

  // @@protoc_insertion_point(class_scope:flower.transport.ClientMessage.ParametersRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flower::transport::Parameters* parameters_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_transport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientMessage_FitRes_MetricsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ClientMessage_FitRes_MetricsEntry_DoNotUse, 
    ::std::string, ::flower::transport::Scalar,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ClientMessage_FitRes_MetricsEntry_DoNotUse, 
    ::std::string, ::flower::transport::Scalar,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  ClientMessage_FitRes_MetricsEntry_DoNotUse();
  ClientMessage_FitRes_MetricsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ClientMessage_FitRes_MetricsEntry_DoNotUse& other);
  static const ClientMessage_FitRes_MetricsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ClientMessage_FitRes_MetricsEntry_DoNotUse*>(&_ClientMessage_FitRes_MetricsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ClientMessage_FitRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flower.transport.ClientMessage.FitRes) */ {
 public:
  ClientMessage_FitRes();
  virtual ~ClientMessage_FitRes();

  ClientMessage_FitRes(const ClientMessage_FitRes& from);

  inline ClientMessage_FitRes& operator=(const ClientMessage_FitRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientMessage_FitRes(ClientMessage_FitRes&& from) noexcept
    : ClientMessage_FitRes() {
    *this = ::std::move(from);
  }

  inline ClientMessage_FitRes& operator=(ClientMessage_FitRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_FitRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientMessage_FitRes* internal_default_instance() {
    return reinterpret_cast<const ClientMessage_FitRes*>(
               &_ClientMessage_FitRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ClientMessage_FitRes* other);
  friend void swap(ClientMessage_FitRes& a, ClientMessage_FitRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientMessage_FitRes* New() const final {
    return CreateMaybeMessage<ClientMessage_FitRes>(NULL);
  }

  ClientMessage_FitRes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientMessage_FitRes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientMessage_FitRes& from);
  void MergeFrom(const ClientMessage_FitRes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientMessage_FitRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .flower.transport.Scalar> metrics = 5;
  int metrics_size() const;
  void clear_metrics();
  static const int kMetricsFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::flower::transport::Scalar >&
      metrics() const;
  ::google::protobuf::Map< ::std::string, ::flower::transport::Scalar >*
      mutable_metrics();

  // .flower.transport.Parameters parameters = 1;
  bool has_parameters() const;
  void clear_parameters();
  static const int kParametersFieldNumber = 1;
  private:
  const ::flower::transport::Parameters& _internal_parameters() const;
  public:
  const ::flower::transport::Parameters& parameters() const;
  ::flower::transport::Parameters* release_parameters();
  ::flower::transport::Parameters* mutable_parameters();
  void set_allocated_parameters(::flower::transport::Parameters* parameters);

  // int64 num_examples = 2;
  void clear_num_examples();
  static const int kNumExamplesFieldNumber = 2;
  ::google::protobuf::int64 num_examples() const;
  void set_num_examples(::google::protobuf::int64 value);

  // int64 num_examples_ceil = 3 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_num_examples_ceil();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kNumExamplesCeilFieldNumber = 3;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::int64 num_examples_ceil() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_num_examples_ceil(::google::protobuf::int64 value);

  // float fit_duration = 4 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_fit_duration();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kFitDurationFieldNumber = 4;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR float fit_duration() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_fit_duration(float value);

  // @@protoc_insertion_point(class_scope:flower.transport.ClientMessage.FitRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      ClientMessage_FitRes_MetricsEntry_DoNotUse,
      ::std::string, ::flower::transport::Scalar,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > metrics_;
  ::flower::transport::Parameters* parameters_;
  ::google::protobuf::int64 num_examples_;
  ::google::protobuf::int64 num_examples_ceil_;
  float fit_duration_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_transport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientMessage_EvaluateRes_MetricsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ClientMessage_EvaluateRes_MetricsEntry_DoNotUse, 
    ::std::string, ::flower::transport::Scalar,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ClientMessage_EvaluateRes_MetricsEntry_DoNotUse, 
    ::std::string, ::flower::transport::Scalar,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  ClientMessage_EvaluateRes_MetricsEntry_DoNotUse();
  ClientMessage_EvaluateRes_MetricsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ClientMessage_EvaluateRes_MetricsEntry_DoNotUse& other);
  static const ClientMessage_EvaluateRes_MetricsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ClientMessage_EvaluateRes_MetricsEntry_DoNotUse*>(&_ClientMessage_EvaluateRes_MetricsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ClientMessage_EvaluateRes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flower.transport.ClientMessage.EvaluateRes) */ {
 public:
  ClientMessage_EvaluateRes();
  virtual ~ClientMessage_EvaluateRes();

  ClientMessage_EvaluateRes(const ClientMessage_EvaluateRes& from);

  inline ClientMessage_EvaluateRes& operator=(const ClientMessage_EvaluateRes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientMessage_EvaluateRes(ClientMessage_EvaluateRes&& from) noexcept
    : ClientMessage_EvaluateRes() {
    *this = ::std::move(from);
  }

  inline ClientMessage_EvaluateRes& operator=(ClientMessage_EvaluateRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage_EvaluateRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientMessage_EvaluateRes* internal_default_instance() {
    return reinterpret_cast<const ClientMessage_EvaluateRes*>(
               &_ClientMessage_EvaluateRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ClientMessage_EvaluateRes* other);
  friend void swap(ClientMessage_EvaluateRes& a, ClientMessage_EvaluateRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientMessage_EvaluateRes* New() const final {
    return CreateMaybeMessage<ClientMessage_EvaluateRes>(NULL);
  }

  ClientMessage_EvaluateRes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientMessage_EvaluateRes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientMessage_EvaluateRes& from);
  void MergeFrom(const ClientMessage_EvaluateRes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientMessage_EvaluateRes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .flower.transport.Scalar> metrics = 4;
  int metrics_size() const;
  void clear_metrics();
  static const int kMetricsFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::flower::transport::Scalar >&
      metrics() const;
  ::google::protobuf::Map< ::std::string, ::flower::transport::Scalar >*
      mutable_metrics();

  // int64 num_examples = 1;
  void clear_num_examples();
  static const int kNumExamplesFieldNumber = 1;
  ::google::protobuf::int64 num_examples() const;
  void set_num_examples(::google::protobuf::int64 value);

  // float loss = 2;
  void clear_loss();
  static const int kLossFieldNumber = 2;
  float loss() const;
  void set_loss(float value);

  // float accuracy = 3 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_accuracy();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kAccuracyFieldNumber = 3;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR float accuracy() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_accuracy(float value);

  // @@protoc_insertion_point(class_scope:flower.transport.ClientMessage.EvaluateRes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      ClientMessage_EvaluateRes_MetricsEntry_DoNotUse,
      ::std::string, ::flower::transport::Scalar,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > metrics_;
  ::google::protobuf::int64 num_examples_;
  float loss_;
  float accuracy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_transport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flower.transport.ClientMessage) */ {
 public:
  ClientMessage();
  virtual ~ClientMessage();

  ClientMessage(const ClientMessage& from);

  inline ClientMessage& operator=(const ClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientMessage(ClientMessage&& from) noexcept
    : ClientMessage() {
    *this = ::std::move(from);
  }

  inline ClientMessage& operator=(ClientMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage& default_instance();

  enum MsgCase {
    kDisconnect = 1,
    kParametersRes = 2,
    kFitRes = 3,
    kEvaluateRes = 4,
    MSG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientMessage* internal_default_instance() {
    return reinterpret_cast<const ClientMessage*>(
               &_ClientMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ClientMessage* other);
  friend void swap(ClientMessage& a, ClientMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientMessage* New() const final {
    return CreateMaybeMessage<ClientMessage>(NULL);
  }

  ClientMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientMessage& from);
  void MergeFrom(const ClientMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClientMessage_Disconnect Disconnect;
  typedef ClientMessage_ParametersRes ParametersRes;
  typedef ClientMessage_FitRes FitRes;
  typedef ClientMessage_EvaluateRes EvaluateRes;

  // accessors -------------------------------------------------------

  // .flower.transport.ClientMessage.Disconnect disconnect = 1;
  bool has_disconnect() const;
  void clear_disconnect();
  static const int kDisconnectFieldNumber = 1;
  private:
  const ::flower::transport::ClientMessage_Disconnect& _internal_disconnect() const;
  public:
  const ::flower::transport::ClientMessage_Disconnect& disconnect() const;
  ::flower::transport::ClientMessage_Disconnect* release_disconnect();
  ::flower::transport::ClientMessage_Disconnect* mutable_disconnect();
  void set_allocated_disconnect(::flower::transport::ClientMessage_Disconnect* disconnect);

  // .flower.transport.ClientMessage.ParametersRes parameters_res = 2;
  bool has_parameters_res() const;
  void clear_parameters_res();
  static const int kParametersResFieldNumber = 2;
  private:
  const ::flower::transport::ClientMessage_ParametersRes& _internal_parameters_res() const;
  public:
  const ::flower::transport::ClientMessage_ParametersRes& parameters_res() const;
  ::flower::transport::ClientMessage_ParametersRes* release_parameters_res();
  ::flower::transport::ClientMessage_ParametersRes* mutable_parameters_res();
  void set_allocated_parameters_res(::flower::transport::ClientMessage_ParametersRes* parameters_res);

  // .flower.transport.ClientMessage.FitRes fit_res = 3;
  bool has_fit_res() const;
  void clear_fit_res();
  static const int kFitResFieldNumber = 3;
  private:
  const ::flower::transport::ClientMessage_FitRes& _internal_fit_res() const;
  public:
  const ::flower::transport::ClientMessage_FitRes& fit_res() const;
  ::flower::transport::ClientMessage_FitRes* release_fit_res();
  ::flower::transport::ClientMessage_FitRes* mutable_fit_res();
  void set_allocated_fit_res(::flower::transport::ClientMessage_FitRes* fit_res);

  // .flower.transport.ClientMessage.EvaluateRes evaluate_res = 4;
  bool has_evaluate_res() const;
  void clear_evaluate_res();
  static const int kEvaluateResFieldNumber = 4;
  private:
  const ::flower::transport::ClientMessage_EvaluateRes& _internal_evaluate_res() const;
  public:
  const ::flower::transport::ClientMessage_EvaluateRes& evaluate_res() const;
  ::flower::transport::ClientMessage_EvaluateRes* release_evaluate_res();
  ::flower::transport::ClientMessage_EvaluateRes* mutable_evaluate_res();
  void set_allocated_evaluate_res(::flower::transport::ClientMessage_EvaluateRes* evaluate_res);

  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:flower.transport.ClientMessage)
 private:
  void set_has_disconnect();
  void set_has_parameters_res();
  void set_has_fit_res();
  void set_has_evaluate_res();

  inline bool has_msg() const;
  inline void clear_has_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union MsgUnion {
    MsgUnion() {}
    ::flower::transport::ClientMessage_Disconnect* disconnect_;
    ::flower::transport::ClientMessage_ParametersRes* parameters_res_;
    ::flower::transport::ClientMessage_FitRes* fit_res_;
    ::flower::transport::ClientMessage_EvaluateRes* evaluate_res_;
  } msg_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_transport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scalar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flower.transport.Scalar) */ {
 public:
  Scalar();
  virtual ~Scalar();

  Scalar(const Scalar& from);

  inline Scalar& operator=(const Scalar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scalar(Scalar&& from) noexcept
    : Scalar() {
    *this = ::std::move(from);
  }

  inline Scalar& operator=(Scalar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scalar& default_instance();

  enum ScalarCase {
    kDouble = 1,
    kSint64 = 8,
    kBool = 13,
    kString = 14,
    kBytes = 15,
    SCALAR_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scalar* internal_default_instance() {
    return reinterpret_cast<const Scalar*>(
               &_Scalar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Scalar* other);
  friend void swap(Scalar& a, Scalar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scalar* New() const final {
    return CreateMaybeMessage<Scalar>(NULL);
  }

  Scalar* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scalar>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scalar& from);
  void MergeFrom(const Scalar& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scalar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double double = 1;
  private:
  bool has_double_() const;
  public:
  void clear_double_();
  static const int kDoubleFieldNumber = 1;
  double double_() const;
  void set_double_(double value);

  // sint64 sint64 = 8;
  private:
  bool has_sint64() const;
  public:
  void clear_sint64();
  static const int kSint64FieldNumber = 8;
  ::google::protobuf::int64 sint64() const;
  void set_sint64(::google::protobuf::int64 value);

  // bool bool = 13;
  private:
  bool has_bool_() const;
  public:
  void clear_bool_();
  static const int kBoolFieldNumber = 13;
  bool bool_() const;
  void set_bool_(bool value);

  // string string = 14;
  private:
  bool has_string() const;
  public:
  void clear_string();
  static const int kStringFieldNumber = 14;
  const ::std::string& string() const;
  void set_string(const ::std::string& value);
  #if LANG_CXX11
  void set_string(::std::string&& value);
  #endif
  void set_string(const char* value);
  void set_string(const char* value, size_t size);
  ::std::string* mutable_string();
  ::std::string* release_string();
  void set_allocated_string(::std::string* string);

  // bytes bytes = 15;
  private:
  bool has_bytes() const;
  public:
  void clear_bytes();
  static const int kBytesFieldNumber = 15;
  const ::std::string& bytes() const;
  void set_bytes(const ::std::string& value);
  #if LANG_CXX11
  void set_bytes(::std::string&& value);
  #endif
  void set_bytes(const char* value);
  void set_bytes(const void* value, size_t size);
  ::std::string* mutable_bytes();
  ::std::string* release_bytes();
  void set_allocated_bytes(::std::string* bytes);

  void clear_scalar();
  ScalarCase scalar_case() const;
  // @@protoc_insertion_point(class_scope:flower.transport.Scalar)
 private:
  void set_has_double_();
  void set_has_sint64();
  void set_has_bool_();
  void set_has_string();
  void set_has_bytes();

  inline bool has_scalar() const;
  inline void clear_has_scalar();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ScalarUnion {
    ScalarUnion() {}
    double double__;
    ::google::protobuf::int64 sint64_;
    bool bool__;
    ::google::protobuf::internal::ArenaStringPtr string_;
    ::google::protobuf::internal::ArenaStringPtr bytes_;
  } scalar_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_transport_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Parameters

// repeated bytes tensors = 1;
inline int Parameters::tensors_size() const {
  return tensors_.size();
}
inline void Parameters::clear_tensors() {
  tensors_.Clear();
}
inline const ::std::string& Parameters::tensors(int index) const {
  // @@protoc_insertion_point(field_get:flower.transport.Parameters.tensors)
  return tensors_.Get(index);
}
inline ::std::string* Parameters::mutable_tensors(int index) {
  // @@protoc_insertion_point(field_mutable:flower.transport.Parameters.tensors)
  return tensors_.Mutable(index);
}
inline void Parameters::set_tensors(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:flower.transport.Parameters.tensors)
  tensors_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Parameters::set_tensors(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:flower.transport.Parameters.tensors)
  tensors_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Parameters::set_tensors(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tensors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flower.transport.Parameters.tensors)
}
inline void Parameters::set_tensors(int index, const void* value, size_t size) {
  tensors_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flower.transport.Parameters.tensors)
}
inline ::std::string* Parameters::add_tensors() {
  // @@protoc_insertion_point(field_add_mutable:flower.transport.Parameters.tensors)
  return tensors_.Add();
}
inline void Parameters::add_tensors(const ::std::string& value) {
  tensors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flower.transport.Parameters.tensors)
}
#if LANG_CXX11
inline void Parameters::add_tensors(::std::string&& value) {
  tensors_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flower.transport.Parameters.tensors)
}
#endif
inline void Parameters::add_tensors(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tensors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flower.transport.Parameters.tensors)
}
inline void Parameters::add_tensors(const void* value, size_t size) {
  tensors_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flower.transport.Parameters.tensors)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Parameters::tensors() const {
  // @@protoc_insertion_point(field_list:flower.transport.Parameters.tensors)
  return tensors_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Parameters::mutable_tensors() {
  // @@protoc_insertion_point(field_mutable_list:flower.transport.Parameters.tensors)
  return &tensors_;
}

// string tensor_type = 2;
inline void Parameters::clear_tensor_type() {
  tensor_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Parameters::tensor_type() const {
  // @@protoc_insertion_point(field_get:flower.transport.Parameters.tensor_type)
  return tensor_type_.GetNoArena();
}
inline void Parameters::set_tensor_type(const ::std::string& value) {
  
  tensor_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flower.transport.Parameters.tensor_type)
}
#if LANG_CXX11
inline void Parameters::set_tensor_type(::std::string&& value) {
  
  tensor_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flower.transport.Parameters.tensor_type)
}
#endif
inline void Parameters::set_tensor_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tensor_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flower.transport.Parameters.tensor_type)
}
inline void Parameters::set_tensor_type(const char* value, size_t size) {
  
  tensor_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flower.transport.Parameters.tensor_type)
}
inline ::std::string* Parameters::mutable_tensor_type() {
  
  // @@protoc_insertion_point(field_mutable:flower.transport.Parameters.tensor_type)
  return tensor_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Parameters::release_tensor_type() {
  // @@protoc_insertion_point(field_release:flower.transport.Parameters.tensor_type)
  
  return tensor_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Parameters::set_allocated_tensor_type(::std::string* tensor_type) {
  if (tensor_type != NULL) {
    
  } else {
    
  }
  tensor_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tensor_type);
  // @@protoc_insertion_point(field_set_allocated:flower.transport.Parameters.tensor_type)
}

// -------------------------------------------------------------------

// ServerMessage_Reconnect

// int64 seconds = 1;
inline void ServerMessage_Reconnect::clear_seconds() {
  seconds_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ServerMessage_Reconnect::seconds() const {
  // @@protoc_insertion_point(field_get:flower.transport.ServerMessage.Reconnect.seconds)
  return seconds_;
}
inline void ServerMessage_Reconnect::set_seconds(::google::protobuf::int64 value) {
  
  seconds_ = value;
  // @@protoc_insertion_point(field_set:flower.transport.ServerMessage.Reconnect.seconds)
}

// -------------------------------------------------------------------

// ServerMessage_GetParameters

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ServerMessage_FitIns

// .flower.transport.Parameters parameters = 1;
inline bool ServerMessage_FitIns::has_parameters() const {
  return this != internal_default_instance() && parameters_ != NULL;
}
inline void ServerMessage_FitIns::clear_parameters() {
  if (GetArenaNoVirtual() == NULL && parameters_ != NULL) {
    delete parameters_;
  }
  parameters_ = NULL;
}
inline const ::flower::transport::Parameters& ServerMessage_FitIns::_internal_parameters() const {
  return *parameters_;
}
inline const ::flower::transport::Parameters& ServerMessage_FitIns::parameters() const {
  const ::flower::transport::Parameters* p = parameters_;
  // @@protoc_insertion_point(field_get:flower.transport.ServerMessage.FitIns.parameters)
  return p != NULL ? *p : *reinterpret_cast<const ::flower::transport::Parameters*>(
      &::flower::transport::_Parameters_default_instance_);
}
inline ::flower::transport::Parameters* ServerMessage_FitIns::release_parameters() {
  // @@protoc_insertion_point(field_release:flower.transport.ServerMessage.FitIns.parameters)
  
  ::flower::transport::Parameters* temp = parameters_;
  parameters_ = NULL;
  return temp;
}
inline ::flower::transport::Parameters* ServerMessage_FitIns::mutable_parameters() {
  
  if (parameters_ == NULL) {
    auto* p = CreateMaybeMessage<::flower::transport::Parameters>(GetArenaNoVirtual());
    parameters_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flower.transport.ServerMessage.FitIns.parameters)
  return parameters_;
}
inline void ServerMessage_FitIns::set_allocated_parameters(::flower::transport::Parameters* parameters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parameters_;
  }
  if (parameters) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parameters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parameters, submessage_arena);
    }
    
  } else {
    
  }
  parameters_ = parameters;
  // @@protoc_insertion_point(field_set_allocated:flower.transport.ServerMessage.FitIns.parameters)
}

// map<string, .flower.transport.Scalar> config = 2;
inline int ServerMessage_FitIns::config_size() const {
  return config_.size();
}
inline void ServerMessage_FitIns::clear_config() {
  config_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::flower::transport::Scalar >&
ServerMessage_FitIns::config() const {
  // @@protoc_insertion_point(field_map:flower.transport.ServerMessage.FitIns.config)
  return config_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::flower::transport::Scalar >*
ServerMessage_FitIns::mutable_config() {
  // @@protoc_insertion_point(field_mutable_map:flower.transport.ServerMessage.FitIns.config)
  return config_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ServerMessage_EvaluateIns

// .flower.transport.Parameters parameters = 1;
inline bool ServerMessage_EvaluateIns::has_parameters() const {
  return this != internal_default_instance() && parameters_ != NULL;
}
inline void ServerMessage_EvaluateIns::clear_parameters() {
  if (GetArenaNoVirtual() == NULL && parameters_ != NULL) {
    delete parameters_;
  }
  parameters_ = NULL;
}
inline const ::flower::transport::Parameters& ServerMessage_EvaluateIns::_internal_parameters() const {
  return *parameters_;
}
inline const ::flower::transport::Parameters& ServerMessage_EvaluateIns::parameters() const {
  const ::flower::transport::Parameters* p = parameters_;
  // @@protoc_insertion_point(field_get:flower.transport.ServerMessage.EvaluateIns.parameters)
  return p != NULL ? *p : *reinterpret_cast<const ::flower::transport::Parameters*>(
      &::flower::transport::_Parameters_default_instance_);
}
inline ::flower::transport::Parameters* ServerMessage_EvaluateIns::release_parameters() {
  // @@protoc_insertion_point(field_release:flower.transport.ServerMessage.EvaluateIns.parameters)
  
  ::flower::transport::Parameters* temp = parameters_;
  parameters_ = NULL;
  return temp;
}
inline ::flower::transport::Parameters* ServerMessage_EvaluateIns::mutable_parameters() {
  
  if (parameters_ == NULL) {
    auto* p = CreateMaybeMessage<::flower::transport::Parameters>(GetArenaNoVirtual());
    parameters_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flower.transport.ServerMessage.EvaluateIns.parameters)
  return parameters_;
}
inline void ServerMessage_EvaluateIns::set_allocated_parameters(::flower::transport::Parameters* parameters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parameters_;
  }
  if (parameters) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parameters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parameters, submessage_arena);
    }
    
  } else {
    
  }
  parameters_ = parameters;
  // @@protoc_insertion_point(field_set_allocated:flower.transport.ServerMessage.EvaluateIns.parameters)
}

// map<string, .flower.transport.Scalar> config = 2;
inline int ServerMessage_EvaluateIns::config_size() const {
  return config_.size();
}
inline void ServerMessage_EvaluateIns::clear_config() {
  config_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::flower::transport::Scalar >&
ServerMessage_EvaluateIns::config() const {
  // @@protoc_insertion_point(field_map:flower.transport.ServerMessage.EvaluateIns.config)
  return config_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::flower::transport::Scalar >*
ServerMessage_EvaluateIns::mutable_config() {
  // @@protoc_insertion_point(field_mutable_map:flower.transport.ServerMessage.EvaluateIns.config)
  return config_.MutableMap();
}

// -------------------------------------------------------------------

// ServerMessage

// .flower.transport.ServerMessage.Reconnect reconnect = 1;
inline bool ServerMessage::has_reconnect() const {
  return msg_case() == kReconnect;
}
inline void ServerMessage::set_has_reconnect() {
  _oneof_case_[0] = kReconnect;
}
inline void ServerMessage::clear_reconnect() {
  if (has_reconnect()) {
    delete msg_.reconnect_;
    clear_has_msg();
  }
}
inline const ::flower::transport::ServerMessage_Reconnect& ServerMessage::_internal_reconnect() const {
  return *msg_.reconnect_;
}
inline ::flower::transport::ServerMessage_Reconnect* ServerMessage::release_reconnect() {
  // @@protoc_insertion_point(field_release:flower.transport.ServerMessage.reconnect)
  if (has_reconnect()) {
    clear_has_msg();
      ::flower::transport::ServerMessage_Reconnect* temp = msg_.reconnect_;
    msg_.reconnect_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flower::transport::ServerMessage_Reconnect& ServerMessage::reconnect() const {
  // @@protoc_insertion_point(field_get:flower.transport.ServerMessage.reconnect)
  return has_reconnect()
      ? *msg_.reconnect_
      : *reinterpret_cast< ::flower::transport::ServerMessage_Reconnect*>(&::flower::transport::_ServerMessage_Reconnect_default_instance_);
}
inline ::flower::transport::ServerMessage_Reconnect* ServerMessage::mutable_reconnect() {
  if (!has_reconnect()) {
    clear_msg();
    set_has_reconnect();
    msg_.reconnect_ = CreateMaybeMessage< ::flower::transport::ServerMessage_Reconnect >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flower.transport.ServerMessage.reconnect)
  return msg_.reconnect_;
}

// .flower.transport.ServerMessage.GetParameters get_parameters = 2;
inline bool ServerMessage::has_get_parameters() const {
  return msg_case() == kGetParameters;
}
inline void ServerMessage::set_has_get_parameters() {
  _oneof_case_[0] = kGetParameters;
}
inline void ServerMessage::clear_get_parameters() {
  if (has_get_parameters()) {
    delete msg_.get_parameters_;
    clear_has_msg();
  }
}
inline const ::flower::transport::ServerMessage_GetParameters& ServerMessage::_internal_get_parameters() const {
  return *msg_.get_parameters_;
}
inline ::flower::transport::ServerMessage_GetParameters* ServerMessage::release_get_parameters() {
  // @@protoc_insertion_point(field_release:flower.transport.ServerMessage.get_parameters)
  if (has_get_parameters()) {
    clear_has_msg();
      ::flower::transport::ServerMessage_GetParameters* temp = msg_.get_parameters_;
    msg_.get_parameters_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flower::transport::ServerMessage_GetParameters& ServerMessage::get_parameters() const {
  // @@protoc_insertion_point(field_get:flower.transport.ServerMessage.get_parameters)
  return has_get_parameters()
      ? *msg_.get_parameters_
      : *reinterpret_cast< ::flower::transport::ServerMessage_GetParameters*>(&::flower::transport::_ServerMessage_GetParameters_default_instance_);
}
inline ::flower::transport::ServerMessage_GetParameters* ServerMessage::mutable_get_parameters() {
  if (!has_get_parameters()) {
    clear_msg();
    set_has_get_parameters();
    msg_.get_parameters_ = CreateMaybeMessage< ::flower::transport::ServerMessage_GetParameters >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flower.transport.ServerMessage.get_parameters)
  return msg_.get_parameters_;
}

// .flower.transport.ServerMessage.FitIns fit_ins = 3;
inline bool ServerMessage::has_fit_ins() const {
  return msg_case() == kFitIns;
}
inline void ServerMessage::set_has_fit_ins() {
  _oneof_case_[0] = kFitIns;
}
inline void ServerMessage::clear_fit_ins() {
  if (has_fit_ins()) {
    delete msg_.fit_ins_;
    clear_has_msg();
  }
}
inline const ::flower::transport::ServerMessage_FitIns& ServerMessage::_internal_fit_ins() const {
  return *msg_.fit_ins_;
}
inline ::flower::transport::ServerMessage_FitIns* ServerMessage::release_fit_ins() {
  // @@protoc_insertion_point(field_release:flower.transport.ServerMessage.fit_ins)
  if (has_fit_ins()) {
    clear_has_msg();
      ::flower::transport::ServerMessage_FitIns* temp = msg_.fit_ins_;
    msg_.fit_ins_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flower::transport::ServerMessage_FitIns& ServerMessage::fit_ins() const {
  // @@protoc_insertion_point(field_get:flower.transport.ServerMessage.fit_ins)
  return has_fit_ins()
      ? *msg_.fit_ins_
      : *reinterpret_cast< ::flower::transport::ServerMessage_FitIns*>(&::flower::transport::_ServerMessage_FitIns_default_instance_);
}
inline ::flower::transport::ServerMessage_FitIns* ServerMessage::mutable_fit_ins() {
  if (!has_fit_ins()) {
    clear_msg();
    set_has_fit_ins();
    msg_.fit_ins_ = CreateMaybeMessage< ::flower::transport::ServerMessage_FitIns >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flower.transport.ServerMessage.fit_ins)
  return msg_.fit_ins_;
}

// .flower.transport.ServerMessage.EvaluateIns evaluate_ins = 4;
inline bool ServerMessage::has_evaluate_ins() const {
  return msg_case() == kEvaluateIns;
}
inline void ServerMessage::set_has_evaluate_ins() {
  _oneof_case_[0] = kEvaluateIns;
}
inline void ServerMessage::clear_evaluate_ins() {
  if (has_evaluate_ins()) {
    delete msg_.evaluate_ins_;
    clear_has_msg();
  }
}
inline const ::flower::transport::ServerMessage_EvaluateIns& ServerMessage::_internal_evaluate_ins() const {
  return *msg_.evaluate_ins_;
}
inline ::flower::transport::ServerMessage_EvaluateIns* ServerMessage::release_evaluate_ins() {
  // @@protoc_insertion_point(field_release:flower.transport.ServerMessage.evaluate_ins)
  if (has_evaluate_ins()) {
    clear_has_msg();
      ::flower::transport::ServerMessage_EvaluateIns* temp = msg_.evaluate_ins_;
    msg_.evaluate_ins_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flower::transport::ServerMessage_EvaluateIns& ServerMessage::evaluate_ins() const {
  // @@protoc_insertion_point(field_get:flower.transport.ServerMessage.evaluate_ins)
  return has_evaluate_ins()
      ? *msg_.evaluate_ins_
      : *reinterpret_cast< ::flower::transport::ServerMessage_EvaluateIns*>(&::flower::transport::_ServerMessage_EvaluateIns_default_instance_);
}
inline ::flower::transport::ServerMessage_EvaluateIns* ServerMessage::mutable_evaluate_ins() {
  if (!has_evaluate_ins()) {
    clear_msg();
    set_has_evaluate_ins();
    msg_.evaluate_ins_ = CreateMaybeMessage< ::flower::transport::ServerMessage_EvaluateIns >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flower.transport.ServerMessage.evaluate_ins)
  return msg_.evaluate_ins_;
}

inline bool ServerMessage::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void ServerMessage::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline ServerMessage::MsgCase ServerMessage::msg_case() const {
  return ServerMessage::MsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientMessage_Disconnect

// .flower.transport.Reason reason = 1;
inline void ClientMessage_Disconnect::clear_reason() {
  reason_ = 0;
}
inline ::flower::transport::Reason ClientMessage_Disconnect::reason() const {
  // @@protoc_insertion_point(field_get:flower.transport.ClientMessage.Disconnect.reason)
  return static_cast< ::flower::transport::Reason >(reason_);
}
inline void ClientMessage_Disconnect::set_reason(::flower::transport::Reason value) {
  
  reason_ = value;
  // @@protoc_insertion_point(field_set:flower.transport.ClientMessage.Disconnect.reason)
}

// -------------------------------------------------------------------

// ClientMessage_ParametersRes

// .flower.transport.Parameters parameters = 1;
inline bool ClientMessage_ParametersRes::has_parameters() const {
  return this != internal_default_instance() && parameters_ != NULL;
}
inline void ClientMessage_ParametersRes::clear_parameters() {
  if (GetArenaNoVirtual() == NULL && parameters_ != NULL) {
    delete parameters_;
  }
  parameters_ = NULL;
}
inline const ::flower::transport::Parameters& ClientMessage_ParametersRes::_internal_parameters() const {
  return *parameters_;
}
inline const ::flower::transport::Parameters& ClientMessage_ParametersRes::parameters() const {
  const ::flower::transport::Parameters* p = parameters_;
  // @@protoc_insertion_point(field_get:flower.transport.ClientMessage.ParametersRes.parameters)
  return p != NULL ? *p : *reinterpret_cast<const ::flower::transport::Parameters*>(
      &::flower::transport::_Parameters_default_instance_);
}
inline ::flower::transport::Parameters* ClientMessage_ParametersRes::release_parameters() {
  // @@protoc_insertion_point(field_release:flower.transport.ClientMessage.ParametersRes.parameters)
  
  ::flower::transport::Parameters* temp = parameters_;
  parameters_ = NULL;
  return temp;
}
inline ::flower::transport::Parameters* ClientMessage_ParametersRes::mutable_parameters() {
  
  if (parameters_ == NULL) {
    auto* p = CreateMaybeMessage<::flower::transport::Parameters>(GetArenaNoVirtual());
    parameters_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flower.transport.ClientMessage.ParametersRes.parameters)
  return parameters_;
}
inline void ClientMessage_ParametersRes::set_allocated_parameters(::flower::transport::Parameters* parameters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parameters_;
  }
  if (parameters) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parameters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parameters, submessage_arena);
    }
    
  } else {
    
  }
  parameters_ = parameters;
  // @@protoc_insertion_point(field_set_allocated:flower.transport.ClientMessage.ParametersRes.parameters)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ClientMessage_FitRes

// .flower.transport.Parameters parameters = 1;
inline bool ClientMessage_FitRes::has_parameters() const {
  return this != internal_default_instance() && parameters_ != NULL;
}
inline void ClientMessage_FitRes::clear_parameters() {
  if (GetArenaNoVirtual() == NULL && parameters_ != NULL) {
    delete parameters_;
  }
  parameters_ = NULL;
}
inline const ::flower::transport::Parameters& ClientMessage_FitRes::_internal_parameters() const {
  return *parameters_;
}
inline const ::flower::transport::Parameters& ClientMessage_FitRes::parameters() const {
  const ::flower::transport::Parameters* p = parameters_;
  // @@protoc_insertion_point(field_get:flower.transport.ClientMessage.FitRes.parameters)
  return p != NULL ? *p : *reinterpret_cast<const ::flower::transport::Parameters*>(
      &::flower::transport::_Parameters_default_instance_);
}
inline ::flower::transport::Parameters* ClientMessage_FitRes::release_parameters() {
  // @@protoc_insertion_point(field_release:flower.transport.ClientMessage.FitRes.parameters)
  
  ::flower::transport::Parameters* temp = parameters_;
  parameters_ = NULL;
  return temp;
}
inline ::flower::transport::Parameters* ClientMessage_FitRes::mutable_parameters() {
  
  if (parameters_ == NULL) {
    auto* p = CreateMaybeMessage<::flower::transport::Parameters>(GetArenaNoVirtual());
    parameters_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flower.transport.ClientMessage.FitRes.parameters)
  return parameters_;
}
inline void ClientMessage_FitRes::set_allocated_parameters(::flower::transport::Parameters* parameters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parameters_;
  }
  if (parameters) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parameters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parameters, submessage_arena);
    }
    
  } else {
    
  }
  parameters_ = parameters;
  // @@protoc_insertion_point(field_set_allocated:flower.transport.ClientMessage.FitRes.parameters)
}

// int64 num_examples = 2;
inline void ClientMessage_FitRes::clear_num_examples() {
  num_examples_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ClientMessage_FitRes::num_examples() const {
  // @@protoc_insertion_point(field_get:flower.transport.ClientMessage.FitRes.num_examples)
  return num_examples_;
}
inline void ClientMessage_FitRes::set_num_examples(::google::protobuf::int64 value) {
  
  num_examples_ = value;
  // @@protoc_insertion_point(field_set:flower.transport.ClientMessage.FitRes.num_examples)
}

// int64 num_examples_ceil = 3 [deprecated = true];
inline void ClientMessage_FitRes::clear_num_examples_ceil() {
  num_examples_ceil_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ClientMessage_FitRes::num_examples_ceil() const {
  // @@protoc_insertion_point(field_get:flower.transport.ClientMessage.FitRes.num_examples_ceil)
  return num_examples_ceil_;
}
inline void ClientMessage_FitRes::set_num_examples_ceil(::google::protobuf::int64 value) {
  
  num_examples_ceil_ = value;
  // @@protoc_insertion_point(field_set:flower.transport.ClientMessage.FitRes.num_examples_ceil)
}

// float fit_duration = 4 [deprecated = true];
inline void ClientMessage_FitRes::clear_fit_duration() {
  fit_duration_ = 0;
}
inline float ClientMessage_FitRes::fit_duration() const {
  // @@protoc_insertion_point(field_get:flower.transport.ClientMessage.FitRes.fit_duration)
  return fit_duration_;
}
inline void ClientMessage_FitRes::set_fit_duration(float value) {
  
  fit_duration_ = value;
  // @@protoc_insertion_point(field_set:flower.transport.ClientMessage.FitRes.fit_duration)
}

// map<string, .flower.transport.Scalar> metrics = 5;
inline int ClientMessage_FitRes::metrics_size() const {
  return metrics_.size();
}
inline void ClientMessage_FitRes::clear_metrics() {
  metrics_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::flower::transport::Scalar >&
ClientMessage_FitRes::metrics() const {
  // @@protoc_insertion_point(field_map:flower.transport.ClientMessage.FitRes.metrics)
  return metrics_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::flower::transport::Scalar >*
ClientMessage_FitRes::mutable_metrics() {
  // @@protoc_insertion_point(field_mutable_map:flower.transport.ClientMessage.FitRes.metrics)
  return metrics_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ClientMessage_EvaluateRes

// int64 num_examples = 1;
inline void ClientMessage_EvaluateRes::clear_num_examples() {
  num_examples_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ClientMessage_EvaluateRes::num_examples() const {
  // @@protoc_insertion_point(field_get:flower.transport.ClientMessage.EvaluateRes.num_examples)
  return num_examples_;
}
inline void ClientMessage_EvaluateRes::set_num_examples(::google::protobuf::int64 value) {
  
  num_examples_ = value;
  // @@protoc_insertion_point(field_set:flower.transport.ClientMessage.EvaluateRes.num_examples)
}

// float loss = 2;
inline void ClientMessage_EvaluateRes::clear_loss() {
  loss_ = 0;
}
inline float ClientMessage_EvaluateRes::loss() const {
  // @@protoc_insertion_point(field_get:flower.transport.ClientMessage.EvaluateRes.loss)
  return loss_;
}
inline void ClientMessage_EvaluateRes::set_loss(float value) {
  
  loss_ = value;
  // @@protoc_insertion_point(field_set:flower.transport.ClientMessage.EvaluateRes.loss)
}

// float accuracy = 3 [deprecated = true];
inline void ClientMessage_EvaluateRes::clear_accuracy() {
  accuracy_ = 0;
}
inline float ClientMessage_EvaluateRes::accuracy() const {
  // @@protoc_insertion_point(field_get:flower.transport.ClientMessage.EvaluateRes.accuracy)
  return accuracy_;
}
inline void ClientMessage_EvaluateRes::set_accuracy(float value) {
  
  accuracy_ = value;
  // @@protoc_insertion_point(field_set:flower.transport.ClientMessage.EvaluateRes.accuracy)
}

// map<string, .flower.transport.Scalar> metrics = 4;
inline int ClientMessage_EvaluateRes::metrics_size() const {
  return metrics_.size();
}
inline void ClientMessage_EvaluateRes::clear_metrics() {
  metrics_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::flower::transport::Scalar >&
ClientMessage_EvaluateRes::metrics() const {
  // @@protoc_insertion_point(field_map:flower.transport.ClientMessage.EvaluateRes.metrics)
  return metrics_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::flower::transport::Scalar >*
ClientMessage_EvaluateRes::mutable_metrics() {
  // @@protoc_insertion_point(field_mutable_map:flower.transport.ClientMessage.EvaluateRes.metrics)
  return metrics_.MutableMap();
}

// -------------------------------------------------------------------

// ClientMessage

// .flower.transport.ClientMessage.Disconnect disconnect = 1;
inline bool ClientMessage::has_disconnect() const {
  return msg_case() == kDisconnect;
}
inline void ClientMessage::set_has_disconnect() {
  _oneof_case_[0] = kDisconnect;
}
inline void ClientMessage::clear_disconnect() {
  if (has_disconnect()) {
    delete msg_.disconnect_;
    clear_has_msg();
  }
}
inline const ::flower::transport::ClientMessage_Disconnect& ClientMessage::_internal_disconnect() const {
  return *msg_.disconnect_;
}
inline ::flower::transport::ClientMessage_Disconnect* ClientMessage::release_disconnect() {
  // @@protoc_insertion_point(field_release:flower.transport.ClientMessage.disconnect)
  if (has_disconnect()) {
    clear_has_msg();
      ::flower::transport::ClientMessage_Disconnect* temp = msg_.disconnect_;
    msg_.disconnect_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flower::transport::ClientMessage_Disconnect& ClientMessage::disconnect() const {
  // @@protoc_insertion_point(field_get:flower.transport.ClientMessage.disconnect)
  return has_disconnect()
      ? *msg_.disconnect_
      : *reinterpret_cast< ::flower::transport::ClientMessage_Disconnect*>(&::flower::transport::_ClientMessage_Disconnect_default_instance_);
}
inline ::flower::transport::ClientMessage_Disconnect* ClientMessage::mutable_disconnect() {
  if (!has_disconnect()) {
    clear_msg();
    set_has_disconnect();
    msg_.disconnect_ = CreateMaybeMessage< ::flower::transport::ClientMessage_Disconnect >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flower.transport.ClientMessage.disconnect)
  return msg_.disconnect_;
}

// .flower.transport.ClientMessage.ParametersRes parameters_res = 2;
inline bool ClientMessage::has_parameters_res() const {
  return msg_case() == kParametersRes;
}
inline void ClientMessage::set_has_parameters_res() {
  _oneof_case_[0] = kParametersRes;
}
inline void ClientMessage::clear_parameters_res() {
  if (has_parameters_res()) {
    delete msg_.parameters_res_;
    clear_has_msg();
  }
}
inline const ::flower::transport::ClientMessage_ParametersRes& ClientMessage::_internal_parameters_res() const {
  return *msg_.parameters_res_;
}
inline ::flower::transport::ClientMessage_ParametersRes* ClientMessage::release_parameters_res() {
  // @@protoc_insertion_point(field_release:flower.transport.ClientMessage.parameters_res)
  if (has_parameters_res()) {
    clear_has_msg();
      ::flower::transport::ClientMessage_ParametersRes* temp = msg_.parameters_res_;
    msg_.parameters_res_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flower::transport::ClientMessage_ParametersRes& ClientMessage::parameters_res() const {
  // @@protoc_insertion_point(field_get:flower.transport.ClientMessage.parameters_res)
  return has_parameters_res()
      ? *msg_.parameters_res_
      : *reinterpret_cast< ::flower::transport::ClientMessage_ParametersRes*>(&::flower::transport::_ClientMessage_ParametersRes_default_instance_);
}
inline ::flower::transport::ClientMessage_ParametersRes* ClientMessage::mutable_parameters_res() {
  if (!has_parameters_res()) {
    clear_msg();
    set_has_parameters_res();
    msg_.parameters_res_ = CreateMaybeMessage< ::flower::transport::ClientMessage_ParametersRes >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flower.transport.ClientMessage.parameters_res)
  return msg_.parameters_res_;
}

// .flower.transport.ClientMessage.FitRes fit_res = 3;
inline bool ClientMessage::has_fit_res() const {
  return msg_case() == kFitRes;
}
inline void ClientMessage::set_has_fit_res() {
  _oneof_case_[0] = kFitRes;
}
inline void ClientMessage::clear_fit_res() {
  if (has_fit_res()) {
    delete msg_.fit_res_;
    clear_has_msg();
  }
}
inline const ::flower::transport::ClientMessage_FitRes& ClientMessage::_internal_fit_res() const {
  return *msg_.fit_res_;
}
inline ::flower::transport::ClientMessage_FitRes* ClientMessage::release_fit_res() {
  // @@protoc_insertion_point(field_release:flower.transport.ClientMessage.fit_res)
  if (has_fit_res()) {
    clear_has_msg();
      ::flower::transport::ClientMessage_FitRes* temp = msg_.fit_res_;
    msg_.fit_res_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flower::transport::ClientMessage_FitRes& ClientMessage::fit_res() const {
  // @@protoc_insertion_point(field_get:flower.transport.ClientMessage.fit_res)
  return has_fit_res()
      ? *msg_.fit_res_
      : *reinterpret_cast< ::flower::transport::ClientMessage_FitRes*>(&::flower::transport::_ClientMessage_FitRes_default_instance_);
}
inline ::flower::transport::ClientMessage_FitRes* ClientMessage::mutable_fit_res() {
  if (!has_fit_res()) {
    clear_msg();
    set_has_fit_res();
    msg_.fit_res_ = CreateMaybeMessage< ::flower::transport::ClientMessage_FitRes >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flower.transport.ClientMessage.fit_res)
  return msg_.fit_res_;
}

// .flower.transport.ClientMessage.EvaluateRes evaluate_res = 4;
inline bool ClientMessage::has_evaluate_res() const {
  return msg_case() == kEvaluateRes;
}
inline void ClientMessage::set_has_evaluate_res() {
  _oneof_case_[0] = kEvaluateRes;
}
inline void ClientMessage::clear_evaluate_res() {
  if (has_evaluate_res()) {
    delete msg_.evaluate_res_;
    clear_has_msg();
  }
}
inline const ::flower::transport::ClientMessage_EvaluateRes& ClientMessage::_internal_evaluate_res() const {
  return *msg_.evaluate_res_;
}
inline ::flower::transport::ClientMessage_EvaluateRes* ClientMessage::release_evaluate_res() {
  // @@protoc_insertion_point(field_release:flower.transport.ClientMessage.evaluate_res)
  if (has_evaluate_res()) {
    clear_has_msg();
      ::flower::transport::ClientMessage_EvaluateRes* temp = msg_.evaluate_res_;
    msg_.evaluate_res_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flower::transport::ClientMessage_EvaluateRes& ClientMessage::evaluate_res() const {
  // @@protoc_insertion_point(field_get:flower.transport.ClientMessage.evaluate_res)
  return has_evaluate_res()
      ? *msg_.evaluate_res_
      : *reinterpret_cast< ::flower::transport::ClientMessage_EvaluateRes*>(&::flower::transport::_ClientMessage_EvaluateRes_default_instance_);
}
inline ::flower::transport::ClientMessage_EvaluateRes* ClientMessage::mutable_evaluate_res() {
  if (!has_evaluate_res()) {
    clear_msg();
    set_has_evaluate_res();
    msg_.evaluate_res_ = CreateMaybeMessage< ::flower::transport::ClientMessage_EvaluateRes >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flower.transport.ClientMessage.evaluate_res)
  return msg_.evaluate_res_;
}

inline bool ClientMessage::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void ClientMessage::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline ClientMessage::MsgCase ClientMessage::msg_case() const {
  return ClientMessage::MsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Scalar

// double double = 1;
inline bool Scalar::has_double_() const {
  return scalar_case() == kDouble;
}
inline void Scalar::set_has_double_() {
  _oneof_case_[0] = kDouble;
}
inline void Scalar::clear_double_() {
  if (has_double_()) {
    scalar_.double__ = 0;
    clear_has_scalar();
  }
}
inline double Scalar::double_() const {
  // @@protoc_insertion_point(field_get:flower.transport.Scalar.double)
  if (has_double_()) {
    return scalar_.double__;
  }
  return 0;
}
inline void Scalar::set_double_(double value) {
  if (!has_double_()) {
    clear_scalar();
    set_has_double_();
  }
  scalar_.double__ = value;
  // @@protoc_insertion_point(field_set:flower.transport.Scalar.double)
}

// sint64 sint64 = 8;
inline bool Scalar::has_sint64() const {
  return scalar_case() == kSint64;
}
inline void Scalar::set_has_sint64() {
  _oneof_case_[0] = kSint64;
}
inline void Scalar::clear_sint64() {
  if (has_sint64()) {
    scalar_.sint64_ = GOOGLE_LONGLONG(0);
    clear_has_scalar();
  }
}
inline ::google::protobuf::int64 Scalar::sint64() const {
  // @@protoc_insertion_point(field_get:flower.transport.Scalar.sint64)
  if (has_sint64()) {
    return scalar_.sint64_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void Scalar::set_sint64(::google::protobuf::int64 value) {
  if (!has_sint64()) {
    clear_scalar();
    set_has_sint64();
  }
  scalar_.sint64_ = value;
  // @@protoc_insertion_point(field_set:flower.transport.Scalar.sint64)
}

// bool bool = 13;
inline bool Scalar::has_bool_() const {
  return scalar_case() == kBool;
}
inline void Scalar::set_has_bool_() {
  _oneof_case_[0] = kBool;
}
inline void Scalar::clear_bool_() {
  if (has_bool_()) {
    scalar_.bool__ = false;
    clear_has_scalar();
  }
}
inline bool Scalar::bool_() const {
  // @@protoc_insertion_point(field_get:flower.transport.Scalar.bool)
  if (has_bool_()) {
    return scalar_.bool__;
  }
  return false;
}
inline void Scalar::set_bool_(bool value) {
  if (!has_bool_()) {
    clear_scalar();
    set_has_bool_();
  }
  scalar_.bool__ = value;
  // @@protoc_insertion_point(field_set:flower.transport.Scalar.bool)
}

// string string = 14;
inline bool Scalar::has_string() const {
  return scalar_case() == kString;
}
inline void Scalar::set_has_string() {
  _oneof_case_[0] = kString;
}
inline void Scalar::clear_string() {
  if (has_string()) {
    scalar_.string_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_scalar();
  }
}
inline const ::std::string& Scalar::string() const {
  // @@protoc_insertion_point(field_get:flower.transport.Scalar.string)
  if (has_string()) {
    return scalar_.string_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Scalar::set_string(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:flower.transport.Scalar.string)
  if (!has_string()) {
    clear_scalar();
    set_has_string();
    scalar_.string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  scalar_.string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flower.transport.Scalar.string)
}
#if LANG_CXX11
inline void Scalar::set_string(::std::string&& value) {
  // @@protoc_insertion_point(field_set:flower.transport.Scalar.string)
  if (!has_string()) {
    clear_scalar();
    set_has_string();
    scalar_.string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  scalar_.string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flower.transport.Scalar.string)
}
#endif
inline void Scalar::set_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_string()) {
    clear_scalar();
    set_has_string();
    scalar_.string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  scalar_.string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flower.transport.Scalar.string)
}
inline void Scalar::set_string(const char* value, size_t size) {
  if (!has_string()) {
    clear_scalar();
    set_has_string();
    scalar_.string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  scalar_.string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flower.transport.Scalar.string)
}
inline ::std::string* Scalar::mutable_string() {
  if (!has_string()) {
    clear_scalar();
    set_has_string();
    scalar_.string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:flower.transport.Scalar.string)
  return scalar_.string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scalar::release_string() {
  // @@protoc_insertion_point(field_release:flower.transport.Scalar.string)
  if (has_string()) {
    clear_has_scalar();
    return scalar_.string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Scalar::set_allocated_string(::std::string* string) {
  if (!has_string()) {
    scalar_.string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_scalar();
  if (string != NULL) {
    set_has_string();
    scalar_.string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), string);
  }
  // @@protoc_insertion_point(field_set_allocated:flower.transport.Scalar.string)
}

// bytes bytes = 15;
inline bool Scalar::has_bytes() const {
  return scalar_case() == kBytes;
}
inline void Scalar::set_has_bytes() {
  _oneof_case_[0] = kBytes;
}
inline void Scalar::clear_bytes() {
  if (has_bytes()) {
    scalar_.bytes_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_scalar();
  }
}
inline const ::std::string& Scalar::bytes() const {
  // @@protoc_insertion_point(field_get:flower.transport.Scalar.bytes)
  if (has_bytes()) {
    return scalar_.bytes_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Scalar::set_bytes(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:flower.transport.Scalar.bytes)
  if (!has_bytes()) {
    clear_scalar();
    set_has_bytes();
    scalar_.bytes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  scalar_.bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flower.transport.Scalar.bytes)
}
#if LANG_CXX11
inline void Scalar::set_bytes(::std::string&& value) {
  // @@protoc_insertion_point(field_set:flower.transport.Scalar.bytes)
  if (!has_bytes()) {
    clear_scalar();
    set_has_bytes();
    scalar_.bytes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  scalar_.bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flower.transport.Scalar.bytes)
}
#endif
inline void Scalar::set_bytes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_bytes()) {
    clear_scalar();
    set_has_bytes();
    scalar_.bytes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  scalar_.bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flower.transport.Scalar.bytes)
}
inline void Scalar::set_bytes(const void* value, size_t size) {
  if (!has_bytes()) {
    clear_scalar();
    set_has_bytes();
    scalar_.bytes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  scalar_.bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flower.transport.Scalar.bytes)
}
inline ::std::string* Scalar::mutable_bytes() {
  if (!has_bytes()) {
    clear_scalar();
    set_has_bytes();
    scalar_.bytes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:flower.transport.Scalar.bytes)
  return scalar_.bytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Scalar::release_bytes() {
  // @@protoc_insertion_point(field_release:flower.transport.Scalar.bytes)
  if (has_bytes()) {
    clear_has_scalar();
    return scalar_.bytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Scalar::set_allocated_bytes(::std::string* bytes) {
  if (!has_bytes()) {
    scalar_.bytes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_scalar();
  if (bytes != NULL) {
    set_has_bytes();
    scalar_.bytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bytes);
  }
  // @@protoc_insertion_point(field_set_allocated:flower.transport.Scalar.bytes)
}

inline bool Scalar::has_scalar() const {
  return scalar_case() != SCALAR_NOT_SET;
}
inline void Scalar::clear_has_scalar() {
  _oneof_case_[0] = SCALAR_NOT_SET;
}
inline Scalar::ScalarCase Scalar::scalar_case() const {
  return Scalar::ScalarCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace transport
}  // namespace flower

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::flower::transport::Reason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flower::transport::Reason>() {
  return ::flower::transport::Reason_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_transport_2eproto
